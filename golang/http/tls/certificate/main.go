package main

import (
	"crypto/rand"
	"crypto/rsa"
	"crypto/tls"
	"crypto/x509"
	"encoding/pem"
	"fmt"
	"io/ioutil"
	"log"
	"math/big"
	"net"
	"net/http"
	"net/http/httptest"
	"time"
)

func main() {
	tmpl, err := createX509CertificateTemplate()
	if err != nil {
		panic(err)
	}
	// attach public key to tmpl
	tmpl.KeyUsage = x509.KeyUsageCertSign | x509.KeyUsageDigitalSignature                         // certificate key can be used for generating signature and signing certs
	tmpl.ExtKeyUsage = []x509.ExtKeyUsage{x509.ExtKeyUsageClientAuth, x509.ExtKeyUsageServerAuth} // ExtKeyUsage represents an extended set of actions that are valid for a given key.
	tmpl.IPAddresses = []net.IP{net.ParseIP("127.0.0.1")}
	tmpl.IsCA = true
	rootKey, err := rsa.GenerateKey(rand.Reader, 2048)

	//create a self-signed certificate
	rootCert, rootCertPEM, err := createX509Cert(tmpl, tmpl, &rootKey.PublicKey, rootKey)
	if err != nil {
		panic(err)
	}
	fmt.Printf("%s\n", rootCertPEM)
	fmt.Printf("%#x\n", rootCert.Signature) // more ugly binary

	//now we will generate a server cert which is signed by rootCert just generated
	serverCertTempl, err := createX509CertificateTemplate()
	if err != nil {
		panic(err)
	}
	serverCertTempl.KeyUsage = x509.KeyUsageDigitalSignature
	serverCertTempl.ExtKeyUsage = []x509.ExtKeyUsage{x509.ExtKeyUsageServerAuth}
	serverCertTempl.IPAddresses = []net.IP{net.ParseIP("127.0.0.1")}
	serverKey, err := rsa.GenerateKey(rand.Reader, 2048)
	if err != nil {
		panic(err)
	}
	_, serverCertPem, err := createX509Cert(serverCertTempl, rootCert, &serverKey.PublicKey, rootKey)
	if err != nil {
		panic(err)
	}
	serverKeyPem := pem.EncodeToMemory(&pem.Block{
		Type:  "RSA PRIVATE KEY",
		Bytes: x509.MarshalPKCS1PrivateKey(serverKey),
	})
	// Create a TLS server cert using pem encoded private key and certificate
	serverTLSCert, err := tls.X509KeyPair(serverCertPem, serverKeyPem)
	if err != nil {
		log.Fatalf("invalid key pair: %v", err)
	}

	ok := func(w http.ResponseWriter, r *http.Request) { w.Write([]byte("HI!")) }
	s := httptest.NewUnstartedServer(http.HandlerFunc(ok))

	// Configure the server to present the certficate we created
	s.TLS = &tls.Config{
		Certificates: []tls.Certificate{serverTLSCert},
	}
	s.StartTLS()
	//configure client to trust the server cert
	certPool := x509.NewCertPool()
	certPool.AppendCertsFromPEM(rootCertPEM) //add rootCert as trusted CA
	client := &http.Client{
		Transport: &http.Transport{
			TLSClientConfig: &tls.Config{
				RootCAs: certPool,
			},
		},
	}
	resp, err := client.Get(s.URL)
	if err != nil {
		panic(err) // should not happend as we now trust the root cert signed certificates
	}
	defer resp.Body.Close()
	b, err := ioutil.ReadAll(resp.Body)
	fmt.Println(string(b)) //HI!
	s.Close()
}

// x509 is a standard digital certificate format, widely used in a many fields including SSL/TLS communications
// however OpenSSH does not use the X509 format, as well as other smart cards prefering simpler certificate templates (less memory demanding)
func createX509CertificateTemplate() (*x509.Certificate, error) {
	serialNumber, err := rand.Int(rand.Reader, new(big.Int).Lsh(big.NewInt(1), 128))
	if err != nil {
		return nil, fmt.Errorf("failed to generate serial number: %v", err)
	}
	tmpl := &x509.Certificate{
		SerialNumber: serialNumber, // this is normally generated by CA
		// Subject:               pkix.Name{Organization: []string{"ideahitme.com"}},
		SignatureAlgorithm:    x509.SHA256WithRSA,
		NotBefore:             time.Now(),
		NotAfter:              time.Now().Add(time.Hour),
		BasicConstraintsValid: true, // sets isCA field to true
	}
	return tmpl, nil
}

func createX509Cert(template, parent *x509.Certificate, pub interface{}, parentPriv interface{}) (cert *x509.Certificate, certPEM []byte, err error) {
	// The certificate is signed by parent. If parent is equal to template then the
	// certificate is self-signed. The parameter pub is the public key of the
	// signee and priv is the private key of the signer
	certDER, err := x509.CreateCertificate(rand.Reader, template, parent, pub, parentPriv)
	if err != nil {
		return
	}
	// parse the resulting certificate so we can use it again
	cert, err = x509.ParseCertificate(certDER)
	if err != nil {
		return
	}
	// PEM encode the certificate (this is a standard TLS encoding)
	b := pem.Block{Type: "CERTIFICATE", Bytes: certDER}
	certPEM = pem.EncodeToMemory(&b)
	return
}
